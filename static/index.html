<!DOCTYPE HTML>
<link rel="stylesheet" href="./style.css">
<html> 
  <head> 
    <title>Websockets Assignment</title> 
    <meta charset="utf-8" /> 
    <meta content='width=device-width; height=device-height; initial-scale=1.0; maximum-scale=1.0; user-scalable=0;' name='viewport' />
    <meta name="viewport" content="width=device-width" />
    <meta name="license" content="
        Copyright 2013 Google, Abram Hindle
        
        Licensed under the Apache License, Version 2.0 (the "License");
        you may not use this file except in compliance with the License.
        You may obtain a copy of the License at
        
            http://www.apache.org/licenses/LICENSE-2.0
        
        Unless required by applicable law or agreed to in writing, software
        distributed under the License is distributed on an "AS IS" BASIS,
        WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        See the License for the specific language governing permissions and
        limitations under the License.
    "/>
    <script src="json2.js"></script>
  </head> 
  <body bgcolor="white" height="100%" width="100%"> 
    <div id="debug"></div>
    <canvas id="c" width="100%" height="100%" style="-webkit-tap-highlight-color: transparent;"></canvas> 
    <!-- center on screen: https://stackoverflow.com/a/2006008 -->
    <form action="" class="Menu" >
        <div class="ToolRow" id="colorStuff">
            <input type="color" name="color" id="color" class="MenuItem FormInput">
            <input type="range" name="alpha" id="alpha" min="0.1" max="1" step="0.1" class="MenuItem FormInput">
        </div>
        <div class="ToolRow" id="brushType">
            <label for="tool_brush_segmented"><!-- Segmented -->
                <input type="radio" name="tool" id="tool_brush_segmented" value="brush_segmented" class="MenuItem FormInput" checked>
                <span></span>
            </label>
            <label for="tool_brush_unified"><!-- Unified -->
                <input type="radio" name="tool" id="tool_brush_unified" value="brush_unified" class="MenuItem FormInput">
                <span></span>
            </label>
            <label for="tool_eraser"><!-- Eraser -->
                <input type="radio" name="tool" id="tool_eraser" value="eraser" class="MenuItem FormInput">
                <span></span>
            </label>
        </div>
        <div class="ToolRow" id="brushTweak">
            <input type="range" name="size" id="size" min="1" step="1" class="MenuItem FormInput">
            <!-- todo: brush image upload -->
            <!-- <input type="file">      -->
        </div>
        <div class="ToolRow" id="regretBar">
            <button formaction="javascript:undo()" class="MenuItem" id="undo"></button>
            <button formaction="javascript:redo()" class="MenuItem" id="redo"></button>
            <button formaction="javascript:clearWorld()" class="MenuItem" id="clear"></button>
        </div>
    </form>
    <script>

// TODO: can move the canvas by having a translate object and moving all enities by that amount on draw frame.

var canvasColor = "white"
var alpha = document.querySelector("#alpha").value
var colour = hexToRGB(document.querySelector("#color").value, alpha);
document.body.style.setProperty('--brush-color', colour);
var brushSize = 10
var penPressure = 1
var tool = document.querySelector('input[type="radio"][name="tool"]:checked').value;
var undoStack = [];
var redoStack = [];

var currentStrokeId = '';

// hex to rgba thing: https://stackoverflow.com/a/28056903
// Can't believe js doesn't have something for this built-in (that i can find in less than a minute)
function hexToRGB(hex, alpha) {
    var r = parseInt(hex.slice(1, 3), 16),
        g = parseInt(hex.slice(3, 5), 16),
        b = parseInt(hex.slice(5, 7), 16);

    if (alpha) {
        return "rgba(" + r + ", " + g + ", " + b + ", " + alpha + ")";
    } else {
        return "rgb(" + r + ", " + g + ", " + b + ")";
    }
}

function clearWorld() {
    undoStack.push({'type': 'clear', 'data': world})
    world={};
    drawNextFrame()
}

menuItems = document.querySelectorAll(".MenuItem.FormInput");
for (menuItem of menuItems) {
    menuItem.addEventListener("change", (event) => {
        switch (event.target.name) {
            case "color":
                colour = hexToRGB(event.target.value, document.querySelector("#alpha").value);
                document.body.style.setProperty('--brush-color', colour);
                document.body.style.setProperty('--color-no-alpha', event.target.value);
                break;
            case "size":
                brushSize = event.target.value;
                document.body.style.setProperty('--brush-size', brushSize);
                break;
            case "alpha":
                alpha = event.target.value;
                colour = hexToRGB(document.querySelector("#color").value, event.target.value);
                document.body.style.setProperty('--brush-color', colour);
                document.body.style.setProperty('--alpha', alpha);
                break;
            case "tool":
                tool = event.target.value;
                break;
            default:
                break;
        }
    });
}
      // Fix me
var canvas = document.getElementById('c');
var host = window.location.host;
var context = canvas.getContext("2d");
var W = canvas.width  = window.innerWidth-6;
var H = canvas.height = window.innerHeight-50;
var wscounter = 0;
var socket;

function debug(str) {
    var debugDiv = document.getElementById('debug');
    debugDiv.innerHTML = "" + str;
}
// debug("Test");

world = {};

// function drawCircle(context,entity) {
//     with(context) {
//         beginPath();                
//         lineWidth = 3;
//         var x = entity["x"];
//         var y = entity["y"];
//         //moveTo(x,y);
//         fillStyle = entity["colour"];
//         strokeStyle = fillStyle;

//         arcRadius = (entity["radius"])  ?  entity["radius"]  :  50
//         // Since vscode wont give me docs I'll get them myself:
//         // MDN: arc(x, y, radius, startAngle, endAngle, counterclockwise)
//         arc(x, y, arcRadius, 0, 2.0 * Math.PI, false);  // AKA draw a circle.
//         stroke();       // See here: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/stroke     
//     }
// }

function prepEntity(entity) {
    if (!entity["colour"]) {
        // alert("color: " + colour)
        entity["colour"] = colour;
    }
    if (!entity["radius"]) {
        entity["radius"] = 50;
    }
    return entity;
}

function clearFrame() {
    with(context) {
	moveTo(0,0);
	fillStyle = canvasColor;
	fillRect(0,0,W,H);
    }
}

function distance2D(x1, y1, x2, y2) {
    return Math.sqrt((x1 - x2)**2 + (y1 - y2)**2)
}

// This actually draws the frame
var count=0;
function renderFrame() {
    clearFrame();
    for (var key in world) {
        var stroke = world[key];
        stroke.draw();
    }
}

var drawNext = true;
// Signals that there's something to be drawn
function drawNextFrame() {
    drawNext = true;
}

// This optionally draws the frame, call this if you're not sure if you should update
// the canvas
function drawFrame() {
    if (drawNext) {
        renderFrame();
        drawNext = false;
    }
}

// This is unpleasent, canvas clicks are not handled well
// So use this code, it works well on multitouch devices as well.

function getPosition(e) {
	if ( e.targetTouches && e.targetTouches.length > 0) {
		var touch = e.targetTouches[0];
		var x = touch.pageX  - canvas.offsetLeft;
		var y = touch.pageY  - canvas.offsetTop;
		return [x,y];
	} else {
		var rect = e.target.getBoundingClientRect();
		var x = e.offsetX || e.pageX - rect.left - window.scrollX;
		var y = e.offsetY || e.pageY - rect.top  - window.scrollY;
		var x = e.pageX  - canvas.offsetLeft;
		var y = e.pageY  - canvas.offsetTop;
		return [x,y];
	}
}

// function addEntity(entity, data) {
//     if (!world[entity]) {
//         if (data.status === 'begin') {
//             undoStack.push([entity]);
//         } else {
//             undoStack[undoStack.length - 1].push(entity);
//         }
//     }
//     world[entity] = data;
//     redoStack = [];
//     drawNextFrame(); // (but should we?)
//     //XXX: Send a XHTML Request that updates the entity you just modified!
// }

// class BulkLogger {
//     constructor() {
//         this.msg = ''
//     }
//     push(data) {
//         if (Array.isArray(data)) {
//             this.msg += '['
//             for (let item of data) {
//                 this.push(item);
//                 this.msg += ', ';
//             }
//             this.msg += '] count: ' + data.length;
//         } else if (typeof data === "object") {
//             this.msg += '{'
//             for (var key in data) {
//                 this.msg += key + ': ';
//                 this.push(data[key]);
//                 this.msg += ', ';
//             }
//             this.msg += '} count: ' + Object.keys(data).length;
//         } else {
//             this.msg += data;
//         }
//     }
//     print(doAlert=false) {
//         // console.log('printed');
//         if (doAlert) {
//             alert(this.msg);
//         } else {
//             console.log(this.msg);
//         }
//     }
// }

function undo() {
    let action = undoStack.pop();
    if (!(typeof action === "object")) {
        // action is a string representing the id of the stroke to undo.
        let stroke = world[action];
        redoStack.push(stroke);
        delete world[action];
    }
    if (action.type === 'clear') {
        // action is an object containing it's type ('clear') and the world data to restore.
        world = action.data;
        redoStack.push('clear');
    }
    drawNextFrame();
}

function redo() {
    let stroke = redoStack.pop();
    // if (Array.isArray(stroke)) {
    //     for (let action of stroke) {
    //         let entity = action.entity;
    //         let data = action.data
    //         world[entity] = data;
    //         if (data.status === 'begin') {
    //             undoStack.push([entity]);
    //         } else {
    //             undoStack[undoStack.length - 1].push(entity);
    //         }
    //     }
    // } else {
    //     if (stroke.type === 'clear') {
    //         clearWorld();
    //     }
    // }
    if (typeof stroke === "object") {
        // the stroke is a Stroke object
        let strokeId = stroke.begin.strokeId;
        world[strokeId] = stroke;
        undoStack.push(strokeId);
    } else if (stroke === 'clear') {
        clearWorld();
    }
    drawNextFrame();
}

var counter = 0;

// We'll assume for now that entities in the same spot on the same layer are the same entity.
function newEntityId(data) {
    return "pos" + data.x * W + data.y + 'time' + Date.now();
}

function repeatAtN(N=100) {
    return "X" + (counter++) % N;
}

function addEntityWithoutName(data) {
    // var name = repeatAtN();
    let name = newEntityId(data);
    addEntity(name,data);
}

/** Make a new entity, adding it to the applicable stroke, or a new stroke if needed.  
 * 
 * If a new stroke is made, it will be added to the world and undoStack
 * automatically. Also clears the redoStack.
 * 
 * Params:
 *  - x: number
 *      - x-coordinates of center of entity.
 *  - y: number
 *      - y-coordinates of center of entity.
 *  - strokeId (optional): string
 *      - The id of the stroke to add to. Leave blank to start a new stroke and add it to the world.
 *  - end (default=false): boolean
 *      - Whether or not the entity is the final point in the stroke (aka: it was added on mouse up).
 * 
 * Return the id (string) of the stroke that the new entity was added to.
*/
function newEntity(x, y, strokeId, end=false) {
    let stroke;
    let data;
    if (!strokeId) {
        strokeId = newEntityId({'x':x, 'y':y});
        data = {'x':x, 'y':y, 'colour':colour, 'radius':brushSize * penPressure, 'strokeId':strokeId};
        stroke = Stroke(data, tool, context);
        world[strokeId] = stroke;
        undoStack.push(strokeId);
        redoStack = [];
    } else {
        data = {'x':x, 'y':y, 'colour':colour, 'radius':brushSize * penPressure, 'strokeId':strokeId};
        stroke = world[strokeId];
        if (end) {
            stroke.end = data;
        } else {
            stroke.mids.push(data);
        }
    }
    data["tool"] = tool;
    socket.send( JSON.stringify( data ) );
    drawNextFrame();
    return strokeId;
}

// canvas + mouse/touch is complicated 
// I give you this because well the mouse/touch stuff is a total
// pain to get right. This has some out of context bug too.
mouse = (function() {
    // Now this isn't the most popular way of doing OO in 
    // Javascript, but it relies on lexical scope and I like it
    // This isn't 301 so I'm not totally bound to OO :)
    var self;    
    self = {
        clicked: 0,
        // these are listener lists append to them
        mousemovers: [],
        mousedraggers: [],
        mousedowners: [],
        mouseuppers: [],
        callListeners: function(listeners,x,y,clicked,e) {
            for (i in listeners) {
                listeners[i](x,y,clicked,e);
            }
        },
        wasClicked: function(e) {
            var pos = getPosition(e);
            var x = pos[0];
            var y = pos[1];
            if (x >= 0 && x <= W && y >= 0 && y <= H) {
                return 1;
            } else {
                return 0;
            }
        },
        mousedown: function(e) {
            e.preventDefault();
            if (self.wasClicked(e)) {
                var pos = getPosition(e);
                var x = pos[0];
                var y = pos[1];
	        self.clicked = 1;
                self.callListeners(self.mousedowners,x,y,self.clicked,e);
                //addEntityWithoutName({'x':x,'y':y,'colour':'red'});
            }
        },
        mouseup: function(e) {
            e.preventDefault();
            //alert(getPosition(e));
            if (self.wasClicked(e)) {
                var pos = getPosition(e);
                var x = pos[0];
                var y = pos[1];
	        //self.poppin(x,y);
	        self.clicked = 0;
                self.selected = -1;
                self.callListeners(self.mouseuppers,x,y,self.clicked,e);
                //addEntityWithoutName({'x':x,'y':y,'colour':'blue'});
            }
        },
        touchstart: function(e) {
            self.lasttouch = e;                                         
            return self.mousedown(e);
        },
        touchend: function(e) {
            var touch = (self.lasttouch)?self.lasttouch:e;
            return self.mouseup(touch);
        },
        mousemove: function(e) {
            e.preventDefault();
            if (self.wasClicked(e)) {
                var pos = getPosition(e);
                var x = pos[0];
                var y = pos[1];
                if (self.clicked != 0) {
                    //self.squeakin(x,y);
                    if (e.pressure) {
                        penPressure = e.pressure;
                    }              
                    self.callListeners(self.mousedraggers,x,y,self.clicked,e);
                }
                self.callListeners(self.mousemovers,x,y,self.clicked,e);
            }            
        },
        touchmove: function(e) {
            self.lasttouch = e;                                         
            return self.mousemove(e);
        },
		                                   
        // Install the mouse listeners
        mouseinstall: function() {
            canvas.addEventListener("mousedown",  self.mousedown, false);
            canvas.addEventListener("pointermove",  self.mousemove, false);
            canvas.addEventListener("mouseup",    self.mouseup, false);
            canvas.addEventListener("mouseout",   self.mouseout, false);
            canvas.addEventListener("touchstart", self.touchstart, false);
            canvas.addEventListener("touchmove",  self.touchmove, false);
            canvas.addEventListener("touchend",   self.touchend, false);
        }
    };
    self.mouseinstall();
    return self;
})();

// Add the application specific mouse listeners!
mouse.mousedowners.push(function(x,y,clicked,e) {
    currentStrokeId = newEntity(x, y);
});

mouse.mouseuppers.push(function(x,y,clicked,e) {
    newEntity(x, y, currentStrokeId, true);
    currentStrokeId = '';
});

mouse.mousedraggers.push(function(x,y,clicked,e) {
    newEntity(x, y, currentStrokeId);
});

Stroke = (function(beginEntity, tool, ctx) {
    // Interesting OOP idea ^, don't mind if I do.
    var self = {
        begin: beginEntity,
        tool: tool,
        ctx: ctx,
        mids: [],
        end: null,
        
        draw: function() {
            self.ctx.beginPath();
            self.ctx.moveTo(self.begin.x, self.begin.y);
            self.ctx.lineCap = "round";

            switch (self.tool) {
                case "brush_segmented":
                    self.ctx.strokeStyle = self.begin.colour;
                    for (let entity of self.mids) {
                        // Smooth line drawing: https://stackoverflow.com/q/35426074
                        // Whoda thunk it could be so simple yet so hard to figure out.
                        // self.ctx.strokeStyle = entity.colour; // Uncomment if strokes with varying color are eventually wanted.
                        self.ctx.lineWidth = entity.radius;
                        self.ctx.lineTo(entity.x, entity.y);
                        self.ctx.stroke();
                        self.ctx.beginPath();
                        self.ctx.moveTo(entity.x, entity.y);
                    }
                    if (self.end) {
                        // Could do some fancy stuff like different lineCap for
                        // begin and end later if we want.
                        // self.ctx.strokeStyle = self.end.colour;  // Uncomment if strokes with varying color are eventually wanted.
                        self.ctx.lineWidth = self.end.radius;
                        self.ctx.lineTo(self.end.x, self.end.y);
                        self.ctx.stroke();
                        // return; //?
                    }
                    break;

                case "brush_unified":
                    // Didn't use it, but the idea might be handy later, and it did help me
                    // understand what I was doing wrong where transparency is concerned:
                    // https://stackoverflow.com/a/6636105
                    self.ctx.strokeStyle = self.begin.colour;
                    self.ctx.lineJoin = "round";
                    {
                        let entity;
                        for (entity of self.mids) {
                            self.ctx.lineTo(entity.x, entity.y);
                        }
                        if (entity) {
                            self.ctx.lineWidth = entity.radius;     // Lets us adjust size of the whole stroke while drawing (if using pressure enabled pen)
                        } else {
                            self.ctx.lineWidth = self.begin.radius;
                        }
                    }
                    if (self.end) {
                        // We intentionally don't adjust lineWidth here in hopes that it will keep
                        // the act of lifting the pen from messing up the line size last minute.
                        self.ctx.lineTo(self.end.x, self.end.y);
                    }
                    self.ctx.stroke();
                    break;

                case "eraser":
                    let clearParams = (x, y, rad) => {
                        let upperRight = [x - rad, y - rad];
                        rad = rad * 2;
                        return [...upperRight, rad, rad];
                    }
                    self.ctx.clearRect(...clearParams(self.begin.x, self.begin.y, self.begin.radius));
                    for (let entity of self.mids) {
                        self.ctx.clearRect(...clearParams(entity.x, entity.y, entity.radius));
                    }
                    if (self.end) {
                        self.ctx.clearRect(...clearParams(self.end.x, self.end.y, self.end.radius));
                    }
                    break;

                default:
                    break;
            }
        },
    };
    return self;
});

function update() {
    drawFrame();
}

function wsSetup() {
    var url = "ws://"+host+"/subscribe";   
    socket = new WebSocket(url);
    socket.onopen = function() {
        //XXX: TODO What are you going to do here?

        // retrieve and render the world? ...hmmm... maybe not
    };
    socket.onerror = function(msg) {
        debug("WebSocket Error:" + msg.data);
    };
    socket.onmessage = function(msg) {  
        try {
            debug("WebSocket Recv:" + msg.data);
            //XXX: TODO What are you going to do here?
            https://github.com/uofa-cmput404/cmput404-slides/blob/master/examples/WebSocketsExamples/static/chat.html
            var message = JSON.parse(msg.data);
            if (message.tail) {
                let different_stroke_from_different_folk = Stroke(message.begin, message.tool, context);
                for (let entity of message.tail) {
                    different_stroke_from_different_folk.mids.push(entity); // Prolly put the end in the mids by mistake but eh.
                }   
            } else if (message.strokeId) {
                let tool = message.tool;
                delete message.tool;
                if (world[message.strokeId]) {
                    world[message.strokeId].mids.push(message);
                } else {
                    // Don't question it, I must be low on sleep and thus have questionable ideas of fun
                    let new_stroke_from_new_bloke = Stroke(message, tool, context);
                    world[message.strokeId] = new_stroke_from_new_bloke;
                }
                // TODO: else if message === "clear" or something, except it's prolly in json. implement ws clearing stuff first.
            }
            // Convert ws data to strokes, add/remove to/from world
        } catch (e) {
            console.log(e);
            alert("socket on message: " + e);
        }
    }; 
}

wsSetup();




// 30 frames per second
setInterval( update, 1000/30.0);


    </script>
</body>
</html>
